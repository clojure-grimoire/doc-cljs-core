{:ns "cljs.analyzer", :name "analyze-let", :file "cljs/analyzer.clj", :type :fn, :src "(defn analyze-let\n  [encl-env [_ bindings & exprs :as form] is-loop]\n  (when-not (and (vector? bindings) (even? (count bindings))) \n    (throw (error encl-env \"bindings must be vector of even number of elements\")))\n  (let [context (:context encl-env)\n        [bes env]\n        (disallowing-recur\n         (loop [bes []\n                env (assoc encl-env :context :expr)\n                bindings (seq (partition 2 bindings))]\n           (if-let [[name init] (first bindings)]\n             (do\n               (when (or (namespace name) (.contains (str name) \".\"))\n                 (throw (error encl-env (str \"Invalid local name: \" name))))\n               (let [init-expr (binding [*loop-lets* (cons {:params bes} *loop-lets*)]\n                                 (analyze env init))\n                     be {:name name\n                         :line (get-line name env)\n                         :column (get-col name env)\n                         :init init-expr\n                         :tag (or (-> name meta :tag)\n                                  (-> init-expr :tag)\n                                  (-> init-expr :info :tag))\n                         :local true\n                         :shadow (-> env :locals name)\n                         ;; Give let* bindings same shape as var so\n                         ;; they get routed correctly in the compiler\n                         :op :var\n                         :env {:line (get-line name env)\n                               :column (get-col name env)}\n                         :info {:name name\n                                :shadow (-> env :locals name)}\n                         :binding-form? true}\n                     be (if (= (:op init-expr) :fn)\n                          ;; TODO: can we simplify - David\n                          (merge be\n                            {:fn-var true\n                             :variadic (:variadic init-expr)\n                             :max-fixed-arity (:max-fixed-arity init-expr)\n                             :method-params (map :params (:methods init-expr))\n                             :methods (:methods init-expr)})\n                          be)]\n                 (recur (conj bes be)\n                        (assoc-in env [:locals name] be)\n                        (next bindings))))\n             [bes env])))\n        recur-frame (when is-loop {:params bes :flag (atom nil)})\n        expr\n        (binding [*recur-frames* (if recur-frame (cons recur-frame *recur-frames*) *recur-frames*)\n                  *loop-lets* (cond\n                                is-loop *loop-lets*\n                                *loop-lets* (cons {:params bes} *loop-lets*))]\n          (analyze (assoc env :context (if (= :expr context) :return context)) `(do ~@exprs)))]\n    {:env encl-env :op (if is-loop :loop :let)\n     :bindings bes :expr expr :form form\n     :children (conj (vec (map :init bes)) expr)}))", :column 1, :line 863, :arglists ([encl-env [_ bindings & exprs :as form] is-loop])}