{:ns "cljs.analyzer", :name "parse-ns", :file "cljs/analyzer.clj", :type :fn, :src "(defn parse-ns\n  ([src] (parse-ns src nil nil))\n  ([src dest opts]\n    (env/ensure\n      (let [namespaces' (::namespaces @env/*compiler*)\n            ret\n            (binding [*cljs-ns* 'cljs.user\n                      *analyze-deps* false]\n              (loop [forms (forms-seq src)]\n                (if (seq forms)\n                  (let [env (empty-env)\n                        ast (no-warn (analyze env (first forms) nil opts))]\n                    (if (= (:op ast) :ns)\n                      (let [ns-name (:name ast)\n                            deps    (merge (:uses ast) (:requires ast))]\n                        (merge\n                          {:ns (or ns-name 'cljs.user)\n                           :provides [ns-name]\n                           :requires (if (= ns-name 'cljs.core)\n                                       (set (vals deps))\n                                       (cond-> (conj (set (vals deps)) 'cljs.core)\n                                         (get-in @env/*compiler* [:opts :emit-constants])\n                                         (conj 'constants-table)))\n                           :file dest\n                           :source-file src}\n                          (when (and dest (.exists ^File dest))\n                            {:lines (with-open [reader (io/reader dest)]\n                                      (-> reader line-seq count))})))\n                      (recur (rest forms)))))))]\n        ;; TODO this _was_ a reset! of the old namespaces atom; should we capture and\n        ;; then restore the entirety of env/*compiler* here instead?\n        (swap! env/*compiler* assoc ::namespaces namespaces')\n        ret))))", :column 1, :line 1656, :arglists ([src] [src dest opts])}