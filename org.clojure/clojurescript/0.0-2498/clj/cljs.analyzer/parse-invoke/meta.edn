{:ns "cljs.analyzer", :name "parse-invoke", :file "cljs/analyzer.clj", :type :fn, :src "(defn parse-invoke\n  [env [f & args :as form]]\n  (disallowing-recur\n   (let [enve    (assoc env :context :expr)\n         fexpr   (analyze enve f)\n         argc    (count args)\n         fn-var? (-> fexpr :info :fn-var)]\n     (when fn-var?\n       (let [{:keys [variadic max-fixed-arity method-params name]} (:info fexpr)]\n         (when (and (not (some #{argc} (map count method-params)))\n                    (or (not variadic)\n                        (and variadic (< argc max-fixed-arity))))\n           (warning :fn-arity env {:name name\n                                   :argc argc}))))\n     (when (and (-> fexpr :info :deprecated)\n                (not (-> form meta :deprecation-nowarn)))\n       (warning :fn-deprecated env {:fexpr fexpr}))\n     (when (-> fexpr :info :type)\n       (warning :invoke-ctor env {:fexpr fexpr}))\n     (if (or (not *cljs-static-fns*) (not (symbol? f)) fn-var? (contains? (meta f) ::analyzed))\n       (let [argexprs (vec (map #(analyze enve %) args))]\n         {:env env :op :invoke :form form :f fexpr :args argexprs\n          :children (into [fexpr] argexprs)})\n       (let [arg-syms (take argc (repeatedly gensym))]\n         (analyze env\n           `(let [~@(vec (interleave arg-syms args))]\n              (~(vary-meta f assoc ::analyzed true) ~@arg-syms))))))))", :column 1, :line 1398, :arglists ([env [f & args :as form]])}